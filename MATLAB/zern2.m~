function [Z, nm] = zern2(img, order, varargin)
%ZERNIKE2 Calculate rotation-invariant Zernike moments for an input image
%
%   Implementation of methods from the following paper:
%   A. Khotanzad and Y. H. Hong, "Invariant Image Recognition by Zernike
%       Moments" (1990)


% Set default varargin values
l = 0;
diagplot = true;
t_init = eye(3);

% Loop over varargin elements
while ~isempty(varargin)
    switch lower(varargin{1})

        case 'lambda'
            l = varargin{2};
            assert(and(isnumeric(l), numel(l)==1, mod(l,1)==0), ...
                "Lambda must be a scalar integer")
        case 'diagnostic'
            diagplot = varargin{2};
        case 'initial'
            t_init = varargin{2};
            assert(and(isnumeric(t_init), all(size(t_init)==[3,3])), ...
                "Initial guess must be a 3x3 numeric array")

    end

    varargin(1:2) = [];
end

% Loop over allowed indices
Z = [];
nm = [];
for n=0:order
    for m=0:n
        if mod(n-abs(m), 2)==0
            % Append Zernike moments and n,m values
            Z = [Z; A(n,m,img)];
            nm = [nm; [n,m]];
        end
    end
end

end

% Calculate Zernike moment Anm (dependent on Vnm)
function Anm = A(n,m,img)

y = ctrrng(size(img, 1));
x = ctrrng(size(img, 2));
[X,Y] = ndgrid(x,y);
r = sqrt(X.^2+Y.^2);
th = mod(atan2(Y,X),2*pi);

Anm = (n+1)/pi * sum(double(img).*conj(V(n,m,r,th)), 'all');

end

% Define Zernike polynomial Vnm (dependent on Rnm)
function Vnm = V(n,m,r,th)

Rnm = R(n,m,r);
Vnm = Rnm * exp(1j * m * th);

end

% Define radial polynomial Rnm
function Rnm = R(n,m,r)

ss = 0:((n-abs(m))/2);
Rnm = 0*r;
for s = ss
    Rnm = Rnm + (-1).^s .* ...
            ff(n-s) / (ff(s) .* ff((n+abs(m))/2 - s) .* ff((n-abs(m))/2 - s)) .* ...
            r.^(n - 2*s);
end

end

% Normalize image coordinates to the unit circle
function y = ctrrng(x)
    y = 1:x;
    y = y - mean(y);
    y = y / max(y);
end

% Shorthand factorial function for readability
function fx = ff(x)
    fx = factorial(x);
end